"""Quality scoring for RAG indexing.

Provides heuristics to assess file quality and filter low-signal content
during the indexing process.
"""

from dataclasses import dataclass
from pathlib import Path


@dataclass
class FileQuality:
    """Quality assessment for a file."""

    score: float  # 0.0 to 1.0
    reasons: list[str]
    is_generated: bool
    has_docstrings: bool
    size_bytes: int


def score_file_quality(file_path: Path, content: str | None = None) -> FileQuality:
    """Score file quality using heuristics.

    Args:
        file_path: Path to the file
        content: Optional file content (if already loaded)

    Returns:
        FileQuality with score and metadata
    """
    score = 0.5  # Baseline
    reasons = []
    is_generated = False
    has_docstrings = False
    size_bytes = 0

    # Load content if not provided
    if content is None and file_path.exists():
        try:
            content = file_path.read_text(encoding="utf-8", errors="ignore")
        except Exception:
            return FileQuality(
                score=0.0, reasons=["Failed to read file"], is_generated=False, has_docstrings=False, size_bytes=0
            )

    if content:
        size_bytes = len(content)

        # Extension scoring
        high_quality_exts = {".md", ".py", ".rs", ".toml", ".yaml", ".yml", ".json", ".txt"}
        medium_quality_exts = {".js", ".ts", ".jsx", ".tsx", ".html", ".css", ".sh"}

        if file_path.suffix in high_quality_exts:
            score += 0.2
            reasons.append("High-quality extension")
        elif file_path.suffix in medium_quality_exts:
            score += 0.1
            reasons.append("Medium-quality extension")

        # Generated code detection
        generated_markers = [
            "auto-generated",
            "do not edit",
            "generated by",
            "automatically generated",
            "code generated",
            "autogenerated",
        ]
        content_lower = content.lower()
        is_generated = any(marker in content_lower for marker in generated_markers)
        if is_generated:
            score -= 0.3
            reasons.append("Generated code detected")

        # Docstring detection (Python)
        if file_path.suffix == ".py":
            has_docstrings = '"""' in content or "'''" in content
            if has_docstrings:
                score += 0.15
                reasons.append("Contains docstrings")

            # Check for test files (lower priority)
            if "test_" in file_path.name or file_path.name.startswith("test"):
                score -= 0.05
                reasons.append("Test file")

        # Markdown quality
        if file_path.suffix == ".md":
            # Check for headers
            if any(line.startswith("#") for line in content.split("\n")):
                score += 0.1
                reasons.append("Well-structured markdown")

        # Size heuristic
        if size_bytes < 100:
            score -= 0.2
            reasons.append("File too small")
        elif size_bytes > 100000:
            score -= 0.15
            reasons.append("File very large")
        elif 1000 <= size_bytes <= 50000:
            score += 0.1
            reasons.append("Good file size")

        # Code density (for Python)
        if file_path.suffix == ".py" and size_bytes > 0:
            lines = content.split("\n")
            non_empty_lines = [line for line in lines if line.strip()]
            if len(non_empty_lines) > 0:
                comment_lines = sum(1 for line in non_empty_lines if line.strip().startswith("#"))
                comment_ratio = comment_lines / len(non_empty_lines)
                if 0.1 <= comment_ratio <= 0.3:
                    score += 0.05
                    reasons.append("Good comment ratio")

    # Clamp score to [0.0, 1.0]
    final_score = max(0.0, min(1.0, score))

    return FileQuality(
        score=final_score,
        reasons=reasons,
        is_generated=is_generated,
        has_docstrings=has_docstrings,
        size_bytes=size_bytes,
    )


def should_index_file(
    file_path: Path, quality_threshold: float = 0.0, content: str | None = None
) -> tuple[bool, FileQuality]:
    """Determine if a file should be indexed based on quality.

    Args:
        file_path: Path to the file
        quality_threshold: Minimum quality score (0.0 to 1.0)
        content: Optional file content

    Returns:
        Tuple of (should_index, quality_assessment)
    """
    quality = score_file_quality(file_path, content)
    should_index = quality.score >= quality_threshold
    return should_index, quality
